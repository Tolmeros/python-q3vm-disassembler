#!/usr/bin/env python
import sys, struct, string, os.path
from LEBinFile import LEBinFile

# python hash() builtin gives different values for 32-bit and 64-bit implementations
# http://effbot.org/zone/python-hash.htm

def c_mul(a, b):
    #v = eval(hex((long(a) * b) & 0xFFFFFFFFL)[:-1])
    # 32-bit signed
    v = a * b
    v = v & 0xffffffffL

    if v > 0x7fffffff:
        v = -(0x100000000 - v)
    return v


def hash32BitSigned (str):
    if not str:
        return 0  # empty
    value = ord(str[0]) << 7
    for char in str:
        value = c_mul(1000003, value) ^ ord(char)
    value = value ^ len(str)
    if value == -1:
        value = -2
    return value

# q3vm_specs.html wrong about header

BASE_DIR = os.path.dirname(os.path.realpath(__file__))

CGAME_SYSCALLS_ASM_FILE = os.path.join(BASE_DIR, "cg_syscalls.asm")
GAME_SYSCALLS_ASM_FILE = os.path.join(BASE_DIR, "g_syscalls.asm")

SYMBOLS_FILE = "symbols.dat"
FUNCTIONS_FILE = "functions.dat"
CONSTANTS_FILE = "constants.dat"

BASEQ3_CGAME_FUNCTIONS_FILE = os.path.join(BASE_DIR, "baseq3-cgame-functions.dat")
BASEQ3_GAME_FUNCTIONS_FILE = os.path.join(BASE_DIR, "baseq3-game-functions.dat")

def usage ():
    print "%s <qvm file> [cgame|game]" % sys.argv[0]
    print "optionally specify cgame or game qvm to match syscalls and function hashes"
    sys.exit (1)

class Opcode:
    def __init__ (self, val, name, parmSize):
        self.val = val
        self.name = name
        self.parmSize = parmSize

OP_NAME = 0
OP_PARM_SIZE = 1
OP_JUMP_PARM = 2
OP_STACK_CHANGE = 3

opcodes = [ \
    ["undef", 0, False, 0],
    ["ignore", 0, False, 0],
    ["break", 0, False, 0],
    ["enter", 4, False, 0],  #FIXME OP_STACK_CHANGE
    ["leave", 4, False, 0],
    ["call", 0, False, -1],  #FIXME OP_STACK_CHANGE
    ["push", 0, False, 1],
    ["pop", 0, False, -1],
    ["const", 4, False, 1],
    ["local", 4, False, 1],
    ["jump", 0, False, -1],
    ["eq", 4, True, -2],
    ["ne", 4, True, -2],
    ["lti", 4, True, -2],
    ["lei", 4, True, -2],
    ["gti", 4, True, -2],
    ["gei", 4, True, -2],
    ["ltu", 4, True, -2],
    ["leu", 4, True, -2],
    ["gtu", 4, True, -2],
    ["geu", 4, True, -2],
    ["eqf", 4, True, -2],
    ["nef", 4, True, -2],
    ["ltf", 4, True, -2],
    ["lef", 4, True, -2],
    ["gtf", 4, True, -2],
    ["gef", 4, True, -2],
    ["load1", 0, False, 0],
    ["load2", 0, False, 0],
    ["load4", 0, False, 0],
    ["store1", 0, False, -2],
    ["store2", 0, False, -2],
    ["store4", 0, False, -2],
    ["arg", 1, False, -1],
    ["block_copy", 4, False, -2],  # docs wrong?
    ["sex8", 0, False, 0],
    ["sex16", 0, False, 0],
    ["negi", 0, False, 0],
    ["add", 0, False, -1],
    ["sub", 0, False, -1],
    ["divi", 0, False, -1],
    ["divu", 0, False, -1],
    ["modi", 0, False, -1],
    ["modu", 0, False, -1],
    ["muli", 0, False, -1],
    ["mulu", 0, False, -1],
    ["band", 0, False, -1],
    ["bor", 0, False, -1],
    ["bxor", 0, False, -1],
    ["bcom", 0, False, 0],
    ["lsh", 0, False, -1],
    ["rshi", 0, False, -1],
    ["rshu", 0, False, -1],
    ["negf", 0, False, 0],
    ["addf", 0, False, -1],
    ["subf", 0, False, -1],
    ["divf", 0, False, -1],
    ["mulf", 0, False, -1],
    ["cvif", 0, False, 0],
    ["cvfi", 0, False, 0]
]

class InvalidQvmFile(Exception):
    pass

class QvmFile(LEBinFile):
    magic = 0x12721444

    # qvmtype:("cgame", "game", ...)
    def __init__ (self, fname, qvmtype=None):
        self._file = open(fname)
        m = self.read_int()
        if m != self.magic:
            raise InvalidQvmFile, "not a valid qvm file  0x%x != 0x%x" % (m, self.magic)

        self.instructionCount = self.read_int()
        self.codeSegOffset = self.read_int()
        self.codeSegLength = self.read_int()
        self.dataSegOffset = self.read_int()
        self.dataSegLength = self.read_int()
        self.litSegOffset = self.dataSegOffset + self.dataSegLength
        self.litSegLength = self.read_int()
        self.bssSegOffset = self.dataSegOffset + self.dataSegLength + self.litSegLength
        self.bssSegLength = self.read_int()

        self.seek (self.codeSegOffset)
        self.codeData = self.read(self.codeSegLength)
        self.codeData = self.codeData + "\x00\x00\x00\x00\x00"  # for look ahead
        self.seek (self.dataSegOffset)
        self.dataData = self.read(self.dataSegLength)
        self.dataData = self.dataData + "\x00\x00\x00\x00"  # for look ahead

        self.seek (self.litSegOffset)
        self.litData = self.read(self.litSegLength)
        self.litData = self.litData + "\x00\x00\x00\x00"  # for look ahead

        self.syscalls = {}
        self.functions = {}
        self.functionHashes = {}
        self.functionRevHashes = {}  # hash -> [func1, func2, ...]
        self.functionSizes = {}
        self.functionMaxArgsCalled = {}
        self.functionParmNum = {}

        self.baseQ3FunctionRevHashes = {}

        self.symbols = {}
        self.constants = {}

        self.jumpPoints = {}  # -> []
        self.callPoints = {}

        self.set_qvm_type (qvmtype)
        self.load_address_info ()
        self.compute_function_info ()

    def set_qvm_type (self, qvmtype):
        self.qvmtype = qvmtype

        if qvmtype not in ("cgame", "game"):
            return

        if qvmtype == "cgame":
            f = open(CGAME_SYSCALLS_ASM_FILE)
        elif qvmtype == "game":
            f = open(GAME_SYSCALLS_ASM_FILE)

        lines = f.readlines()
        for line in lines:
            words = string.split(line)
            if len(words) == 3:
                self.syscalls[string.atoi(words[2])] = words[1]

        if qvmtype == "cgame":
            f = open(BASEQ3_CGAME_FUNCTIONS_FILE)
        elif qvmtype == "game":
            f = open(BASEQ3_GAME_FUNCTIONS_FILE)

        lines = f.readlines()
        for line in lines:
            words = string.split(line)
            if len(words) > 2:
                n = words[1]
                h = string.atoi(words[2], 16)
                if h in self.baseQ3FunctionRevHashes:
                    self.baseQ3FunctionRevHashes[h].append (n)
                else:
                    self.baseQ3FunctionRevHashes[h] = [n]

    def load_address_info (self):
        if os.path.exists(SYMBOLS_FILE):
            f = open(SYMBOLS_FILE)
            lines = f.readlines()
            for line in lines:
                words = string.split(line)
                if len(words) == 2:
                    self.symbols[string.atoi(words[0], 16)] = words[1]

        if os.path.exists(FUNCTIONS_FILE):
            f = open(FUNCTIONS_FILE)
            lines = f.readlines()
            for line in lines:
                words = string.split(line)
                if len(words) > 1:
                    self.functions[string.atoi(words[0], 16)] = words[1]

        if os.path.exists(CONSTANTS_FILE):
            f = open(CONSTANTS_FILE)
            lines = f.readlines()
            for line in lines:
                words = string.split(line)
                if len(words) > 2:
                    codeAddr = string.atoi(words[0], 16)
                    n = words[1]
                    val = string.atoi(words[2], 16)
                    self.constants[codeAddr] = [n, val]

    def print_header (self):
        print "; instruction count: 0x%x" % self.instructionCount
        print "; CODE seg offset: 0x%08x  length: 0x%x" % (self.codeSegOffset, self.codeSegLength)
        print "; DATA seg offset: 0x%08x  length: 0x%x" % (self.dataSegOffset, self.dataSegLength)
        print "; LIT  seg offset: 0x%08x  length: 0x%x" % (self.litSegOffset, self.litSegLength)
        print "; BSS  seg offset: 0x%08x  length: 0x%x" % (self.bssSegOffset, self.bssSegLength)

    def print_code_disassembly (self):
        pos = 0

        count = -1
        while count < self.instructionCount - 1:
            count += 1

            comment = None
            opcStr = self.codeData[pos]
            opc = ord(opcStr)
            pos += 1
            name = opcodes[opc][OP_NAME]
            psize = opcodes[opc][OP_PARM_SIZE]

            if psize == 0:
                parm = None
            elif psize == 1:
                parmStr = self.codeData[pos]
                parm = ord(parmStr)
                pos += 1
            elif psize == 4:
                parmStr = self.codeData[pos : pos + psize]
                parm = struct.unpack("<l", parmStr)[0]
                pos += 4
            else:
                print "FIXME bad opcode size"
                sys.exit (1)

            if count in self.jumpPoints:
                print "\n;----------------------------------- from ",
                for jp in self.jumpPoints[count]:
                    print "0x%x" % jp,
                print ""

            if name == "enter":
                addr = count
                stackAdjust = parm
                if count in self.callPoints:
                    print "\n; called from",
                    for caller in self.callPoints[count]:
                        #print "0x%x" % caller,
                        if caller in self.functions:
                            print "%s()" % self.functions[caller],
                        elif self.functionHashes[caller] in self.baseQ3FunctionRevHashes:
                            for n in self.baseQ3FunctionRevHashes[self.functionHashes[caller]]:
                                print "?%s()" % n,
                        else:
                            print "0x%x" % caller,
                    #print " */"
                    print ""

                print ""

                if addr in self.functions:
                    print "; %s ()" % self.functions[count]
                elif self.functionHashes[addr] in self.baseQ3FunctionRevHashes:
                    print ";",
                    for n in self.baseQ3FunctionRevHashes[self.functionHashes[addr]]:
                        print "?%s()" % n,
                    #print "*/"
                    print ""
                if addr in self.functionParmNum:
                    print ";",
                    p = self.functionParmNum[addr]
                    if p == 0:
                        print "no",
                    elif p == -1:
                        print "var",
                    else:
                        print "0x%x" % p,
                    print "args"

                print "; max local arg 0x%x" % self.functionMaxArgsCalled[addr]
                print "; ========================"
            elif name == "local":
                argNum = parm - stackAdjust - 0x8
                #print argNum
                if argNum >= 0:
                    comment = "arg%d" % (argNum / 4)
            elif name == "const":
                nextOp = ord(self.codeData[pos])

                if count in self.constants:
                    if parm != self.constants[count][1]:
                        comment = "FIXME constant val != to code val"
                    else:
                        comment = self.constants[count][0]

                elif parm >= self.dataSegLength  and  parm < self.dataSegLength + self.litSegLength  and  opcodes[nextOp][OP_NAME] not in ("call", "jump"):
                    chars = []
                    i = 0
                    while 1:
                        c = self.litData[parm - self.dataSegLength + i]
                        if c == '\0':
                            break
                        elif c == '\n':
                            chars.extend (('\\', 'n'))
                        elif c == '\t':
                            chars.extend (('\\', 't'))
                        else:
                            chars.append (c)
                        i += 1
                    print "\n  ; \"%s\"" % string.join(chars, "")
                elif parm >= 0  and  parm < self.dataSegLength  and  opcodes[nextOp][OP_NAME] not in ("call", "jump"):
                    b0 = self.dataData[parm]
                    b1 = self.dataData[parm + 1]
                    b2 = self.dataData[parm + 2]
                    b3 = self.dataData[parm + 3]

                    print "\n  ; %02x %02x %02x %02x  (0x%x)" % (ord(b0), ord(b1), ord(b2), ord(b3), struct.unpack("<L", self.dataData[parm:parm+4])[0])

                    if parm in self.symbols:
                        comment = self.symbols[parm]

                elif opcodes[nextOp][OP_NAME] == "call":
                    if parm < 0  and  parm in self.syscalls:
                        comment = "%s ()" % self.syscalls[parm]
                    elif parm in self.functions:
                        comment = "%s ()" % self.functions[parm]
                    elif parm in self.functionHashes:
                        if self.functionHashes[parm] in self.baseQ3FunctionRevHashes:
                            comment = ""
                            for n in self.baseQ3FunctionRevHashes[self.functionHashes[parm]]:
                                comment += "?%s() " % n
                        else:
                            comment = ":unknown function:"

                elif parm >= self.dataSegLength  and  opcodes[nextOp][OP_NAME] not in ("call", "jump"):
                    # bss segment
                    #FIXME check that it doesn't go past??
                    if parm in self.symbols:
                        comment = self.symbols[parm]

            print "%08x  %-13s" % (count, name),
            sc = opcodes[opc][OP_STACK_CHANGE]
            if sc < 0:
                print " %d" % sc,
            elif sc > 0:
                print "  %d" % sc,
            else:
                print "   ",

            if parm != None:
                if parm < 0:
                    print " -0x%x" % -parm,
                else:
                    print "  0x%x" % parm,
            if comment:
                print "  ; %s" % comment
            else:
                print ""

    def print_data_disassembly (self):
        i = 0
        while i < self.dataSegLength:
            print "0x%08x  " % i,
            b0 = self.dataData[i]
            b1 = self.dataData[i + 1]
            b2 = self.dataData[i + 2]
            b3 = self.dataData[i + 3]

            print "%02x %02x %02x %02x    0x%x" % (ord(b0), ord(b1), ord(b2), ord(b3), struct.unpack("<L", self.dataData[i:i+4])[0])

            i += 4

    def print_lit_disassembly (self):
        pos = self.dataSegLength
        offset = 0
        while offset < self.litSegLength:
            print "0x%08x " % (offset + pos),
            chars = []
            i = 0
            while 1:
                c = self.litData[offset + i]
                if c == '\n':
                    chars.extend (('\\', 'n'))
                elif c == '\t':
                    chars.extend (('\\', 't'))
                elif ord(c) > 31  and  ord(c) < 127:
                    chars.append (c)
                elif c == '\0'  or  offset + i >= self.litSegLength:
                    print "\"%s\"" %  string.join(chars, "")
                    offset = offset + i
                    break
                else:
                    #FIXME
                    #print "invalid char: 0x%x" % ord(c)
                    #sys.exit (1)
                    if len(chars) > 0:
                        print "\"%s\"" % string.join (chars, ""),
                        chars = []
                    print " 0x%x " % ord(c),
                    pass


                i += 1

            offset += 1

    def compute_function_info (self):
        pos = 0
        funcStartInsNum = -1
        funcInsCount = 0
        funcOffset = 0
        funcHashSum = ""
        maxArgs = 0x8
        lastArg = 0x0

        opcStr = "\x00"
        opc = 0
        parmStr = "\x00"
        parm = 0

        prevOpcStr = "\x00"
        prevOpc = 0
        prevOpcParmStr = "\x00"
        prevOpcParm = 0

        ins = -1
        while ins < self.instructionCount - 1:
            ins += 1

            prevOpcStr = opcStr
            prevOpc = opc
            prevParmStr = parmStr
            prevParm = parm

            opcStr = self.codeData[pos]
            opc = ord(opcStr)
            funcInsCount += 1
            funcHashSum += "%d" % opc
            pos += 1
            name = opcodes[opc][OP_NAME]
            psize = opcodes[opc][OP_PARM_SIZE]
            if psize:
                parmStr = self.codeData[pos : pos + psize]
                if psize == 1:
                    parm = ord(parmStr)
                elif psize == 4:
                    parm = struct.unpack("<l", parmStr)[0]
                else:
                    parm = None
            else:
                parmStr = None
                parm = None
            pos += psize

            if name == "const":
                if parm < 0:
                    funcHashSum += "%d" % parm
            elif name == "pop":
                lastArg = 0
            elif name == "local":
                funcHashSum += "%d" % parm
            elif name == "arg":
                if parm > maxArgs:
                    maxArgs = parm
                lastArg = parm
            elif name == "enter":
                if pos > 5:   # else it's first function of file  vmMain()
                    self.functionSizes[funcStartInsNum] = funcInsCount
                    h = hash32BitSigned(funcHashSum)
                    self.functionHashes[funcStartInsNum] = h
                    if h in self.functionRevHashes:
                        self.functionRevHashes[h].append (funcStartInsNum)
                    else:
                        self.functionRevHashes[h] = [funcStartInsNum]
                    self.functionMaxArgsCalled[funcStartInsNum] = maxArgs
                funcStartInsNum = ins
                funcOffset = pos - psize - 1
                funcInsCount = 1
                funcHashSum = ""
                maxArgs = 0x8
                lastArg = 0
            elif opcodes[opc][OP_NAME] == "jump":
                if opcodes[prevOpc][OP_NAME] == "const":
                    if prevParm in self.jumpPoints:
                        self.jumpPoints[prevParm].append (ins)
                    else:
                        self.jumpPoints[prevParm] = [ins]
            elif opcodes[opc][OP_JUMP_PARM]:
                if parm in self.jumpPoints:
                    self.jumpPoints[parm].append (ins)
                else:
                    self.jumpPoints[parm] = [ins]
            elif name == "call":
                if opcodes[prevOpc][OP_NAME] == "const":
                    if prevParm in self.callPoints:
                        self.callPoints[prevParm].append (funcStartInsNum)
                    else:
                        self.callPoints[prevParm] = [funcStartInsNum]
                    if prevParm in self.functionParmNum:
                        x = self.functionParmNum[prevParm]
                        if x != -1:
                            if x != lastArg:
                                self.functionParmNum[prevParm] = -1
                    else:
                        self.functionParmNum[prevParm] = lastArg
        self.functionSizes[funcStartInsNum] = funcInsCount
        h = hash32BitSigned(funcHashSum)
        self.functionHashes[funcStartInsNum] = h
        if h in self.functionRevHashes:
            self.functionRevHashes[h].append (funcStartInsNum)
        else:
            self.functionRevHashes[h] = [funcStartInsNum]
        self.functionMaxArgsCalled[funcStartInsNum] = maxArgs

    def print_function_hashes (self):
        ks = self.functionHashes.keys()
        ks.sort ()
        for addr in ks:
            print "0x%08x  0x%x  %x" % (addr, self.functionSizes[addr], self.functionHashes[addr]),
            if self.functionHashes[addr] in self.baseQ3FunctionRevHashes:
                print "\tpossible match to",
                for n in self.baseQ3FunctionRevHashes[self.functionHashes[addr]]:
                    print n,
            print ""


def main ():
    if len(sys.argv) < 2:
        usage ()

    if len(sys.argv) > 2:
        arg = string.lower(sys.argv[2])
        if arg == "cgame":
            pass
        elif arg == "game":
            pass
        else:
            print "invalid qvm type '%s'" % arg
            usage ()
    else:
        arg = ""

    q = QvmFile(sys.argv[1], arg)

    print ";; header"
    q.print_header ()
    print ""

    print ";; function hashes"
    q.print_function_hashes ()
    print ""

    print ";; code segment"
    q.print_code_disassembly ()
    print ""

    print ";; data segment"
    q.print_data_disassembly ()
    print ""

    print ";; lit segment"
    q.print_lit_disassembly ()


if __name__ == "__main__":
    main ()

