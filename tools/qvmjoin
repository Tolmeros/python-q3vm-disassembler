#!/usr/bin/env python

# Copyright (C) 2012, 2020 Angelo Cano
#
# This file is part of Qvmdis.
#
# Qvmdis is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Qvmdis is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Qvmdis.  If not, see <https://www.gnu.org/licenses/>.

# allow importing from parent directory
# https://stackoverflow.com/questions/714063/importing-modules-from-parent-folder
#  answered Jun 22 '12 at 14:30  Remi
import inspect, os, sys
currentdir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
parentdir = os.path.dirname(currentdir)
sys.path.insert(0,parentdir)

from QvmFile import opcodes, OP_NAME, OP_PARM_SIZE, QVM_MAGIC_VER1
import struct

def atoi (s, base=10):
    return int(s, base)

def usage ():
    sys.stderr.write("%s <output qvm name>\n" % sys.argv[0])
    sys.exit(1)

def main ():
    if len(sys.argv) < 2:
        usage()

    f = open("header-info.txt")
    lines = f.readlines()
    f.close()

    # 'magic: 12345678'
    line = lines[0]
    words = line.split()
    magic = atoi(words[-1])

    # 'bss segment length: 12345678'
    line = lines[2]
    words = line.split()
    bssSegLength = atoi(words[-1])

    # 'jump table length: 12345678'
    if magic != QVM_MAGIC_VER1:
        line = lines[3]
        words = line.split()
        jumpTableLength = atoi(words[-1])
    else:
        jumpTableLength = 0

    f = open("x.code", "rb")
    codeData = f.read()
    f.close()

    # this is just testing opcode parsing
    ins = 0
    pos = 0
    while 1:
        if pos >= len(codeData):
            break
        # use slice to get byte string in python 3
        opcStr = codeData[pos : pos + 1]
        opc = ord(opcStr)
        ins = ins + 1
        pos = pos + 1
        name = opcodes[opc][OP_NAME]
        psize = opcodes[opc][OP_PARM_SIZE]
        if psize:
            parmStr = codeData[pos : pos + psize]
        else:
            parmStr = None
        pos = pos + psize

    #output"0x%x  %d instructions\n" % (ins, ins))

    f = open("x.data", "rb")
    dataData = f.read()
    f.close()

    f = open("x.lit", "rb")
    litData = f.read()
    f.close()

    if magic != QVM_MAGIC_VER1:
        f = open("x.jump", "rb")
        jumpTableData = f.read()
        f.close()

    codePadding = 0
    if (len(codeData) % 4) != 0:
        codePadding = 4 - (len(codeData) % 4)
    codeSegLength = len(codeData) + codePadding

    dataPadding = 0
    if (len(dataData) % 4) != 0:
        dataPadding = 4 - (len(dataData) % 4)
    dataSegLength = len(dataData) + dataPadding

    litPadding = 0
    if (len(litData) % 4) != 0:
        litPadding = 4 - (len(litData) % 4)
    litSegLength = len(litData) + litPadding

    if magic == QVM_MAGIC_VER1:
        codeSegOffset = 0x20
    else:
        codeSegOffset = 0x24

    dataSegOffset = codeSegOffset + codeSegLength

    of = open(sys.argv[1], "wb")
    of.write(struct.pack("<l", magic))
    of.write(struct.pack("<l", ins))   # instruction count
    of.write(struct.pack("<l", codeSegOffset))
    of.write(struct.pack("<l", codeSegLength))
    of.write(struct.pack("<l", dataSegOffset))
    of.write(struct.pack("<l", dataSegLength))
    of.write(struct.pack("<l", litSegLength))
    of.write(struct.pack("<l", bssSegLength))
    if magic != QVM_MAGIC_VER1:
        of.write(struct.pack("<l", jumpTableLength))

    of.write(codeData)
    of.write(b'\x00' * codePadding)

    of.write(dataData)
    of.write(b'\x00' * dataPadding)

    of.write(litData)
    of.write(b'\x00' * litPadding)

    if magic != QVM_MAGIC_VER1:
        of.write(jumpTableData)

    of.close()

if __name__ == "__main__":
    main()
